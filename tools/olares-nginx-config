#!/usr/bin/env python3
"""
Olares Nginx Configuration Generator
为每个部署的应用自动生成 Nginx 反向代理配置
"""

import subprocess
import json
import sys
import os
from pathlib import Path

KUBECTL = "/tmp/kubectl"
NAMESPACE = "opencode-dev-onetest02"
NGINX_CONF_DIR = "/etc/nginx/conf.d/dev"
NGINX_RELOAD_CMD = "nginx -t && nginx -s reload || nginx"


def run_kubectl(args):
    """运行 kubectl 命令"""
    cmd = [KUBECTL] + args + ["-n", NAMESPACE]
    result = subprocess.run(cmd, capture_output=True, text=True)
    return result.returncode, result.stdout, result.stderr


def get_deployed_apps():
    """获取所有已部署的应用"""
    code, stdout, stderr = run_kubectl([
        "get", "deployments",
        "-l", "deployed-by=opencode",
        "-o", "json"
    ])
    
    if code != 0:
        print(f"错误：无法获取部署列表\n{stderr}", file=sys.stderr)
        return []
    
    data = json.loads(stdout)
    apps = []
    
    for item in data.get("items", []):
        name = item["metadata"]["name"]
        
        # 获取端口
        containers = item["spec"]["template"]["spec"]["containers"]
        port = containers[0]["ports"][0]["containerPort"] if containers and containers[0].get("ports") else None
        
        if port:
            apps.append({
                "name": name,
                "port": port,
                "service": f"{name}-svc.{NAMESPACE}.svc.cluster.local"
            })
    
    return apps


def generate_nginx_config(app):
    """为单个应用生成 Nginx 配置"""
    config = f"""# Auto-generated for {app['name']}
location /{app['name']}/ {{
    proxy_pass http://{app['service']}:{app['port']}/;
    proxy_http_version 1.1;
    
    # 标准代理头
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # WebSocket 支持
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    
    # 超时设置
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;
    
    # 禁用缓冲以支持实时响应
    proxy_buffering off;
    proxy_request_buffering off;
}}

# 根路径代理（通过端口号访问）
location /{app['port']}/ {{
    proxy_pass http://{app['service']}:{app['port']}/;
    proxy_http_version 1.1;
    
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    
    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;
    
    proxy_buffering off;
    proxy_request_buffering off;
}}
"""
    return config


def generate_opencode_server_config():
    """为 OpenCode Server 模式生成固定配置（端口 4096）"""
    config = """# Fixed config for OpenCode Server mode (port 4096)
# OpenCode runs at root path, applications at sub-paths

# Fallback: All other paths go to OpenCode Server (must be last)
# Application-specific paths (like /express-demo/) will be matched first
location / {
    proxy_pass http://localhost:4096;
    proxy_http_version 1.1;
    
    # 标准代理头
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # WebSocket 支持
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $http_connection;
    
    # 长连接超时
    proxy_connect_timeout 60s;
    proxy_send_timeout 3600s;
    proxy_read_timeout 3600s;
    
    # 禁用缓冲
    proxy_buffering off;
    proxy_request_buffering off;
}
"""
    return config

def write_nginx_configs(apps):
    """写入所有 Nginx 配置"""
    # 确保配置目录存在
    Path(NGINX_CONF_DIR).mkdir(parents=True, exist_ok=True)
    
    # 清空旧配置（但保留 opencode-server.conf）
    for f in Path(NGINX_CONF_DIR).glob("*.conf"):
        if f.name != "opencode-server.conf":
            f.unlink()
    
    # 写入应用配置
    for app in apps:
        config_file = Path(NGINX_CONF_DIR) / f"{app['name']}.conf"
        config_content = generate_nginx_config(app)
        config_file.write_text(config_content)
        print(f"✓ 生成配置: {config_file}")
    
    # 写入 OpenCode Server 固定配置
    opencode_config_file = Path(NGINX_CONF_DIR) / "opencode-server.conf"
    opencode_config_content = generate_opencode_server_config()
    opencode_config_file.write_text(opencode_config_content)
    print(f"✓ 生成固定配置: {opencode_config_file} (port 4096)")
    
    print(f"\n总共生成 {len(apps)} 个应用的配置 + 1 个固定配置（OpenCode Server）")


def ensure_correct_port():
    """确保 Nginx 监听在 3000 端口（OpenCode 统一入口）"""
    default_conf = Path("/etc/nginx/conf.d/default.conf")
    if default_conf.exists():
        content = default_conf.read_text()
        if "listen 3000" not in content:
            print("⚠️  警告：Nginx 未监听 3000 端口")
            print("   OpenCode 默认通过 3000 端口路由所有请求")
            return False
    return True

def reload_nginx():
    """重载 Nginx 配置"""
    # 检查端口配置
    if not ensure_correct_port():
        print("\n请确保 /etc/nginx/conf.d/default.conf 包含：")
        print("  listen 3000 default_server;")
        return False
    
    print("\n测试 Nginx 配置...")
    result = subprocess.run(["nginx", "-t"], capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"✗ Nginx 配置测试失败:\n{result.stderr}", file=sys.stderr)
        return False
    
    print("✓ Nginx 配置测试通过")
    
    # 检查 Nginx 是否正在运行
    check = subprocess.run(["pgrep", "nginx"], capture_output=True)
    
    if check.returncode == 0:
        # Nginx 正在运行，重载配置
        print("重载 Nginx...")
        result = subprocess.run(["nginx", "-s", "reload"], capture_output=True, text=True)
        if result.returncode == 0:
            print("✓ Nginx 重载成功")
            return True
        else:
            print(f"✗ Nginx 重载失败:\n{result.stderr}", file=sys.stderr)
            return False
    else:
        # Nginx 未运行，启动它
        print("启动 Nginx...")
        result = subprocess.run(["nginx"], capture_output=True, text=True)
        if result.returncode == 0:
            print("✓ Nginx 启动成功")
            return True
        else:
            print(f"✗ Nginx 启动失败:\n{result.stderr}", file=sys.stderr)
            return False


def show_status():
    """显示 Nginx 状态"""
    print("\n" + "="*60)
    print("Nginx 代理状态")
    print("="*60)
    
    # 检查 Nginx 进程
    result = subprocess.run(["pgrep", "-a", "nginx"], capture_output=True, text=True)
    if result.returncode == 0:
        print(f"✓ Nginx 正在运行\n{result.stdout}")
    else:
        print("✗ Nginx 未运行")
    
    # 显示监听端口
    result = subprocess.run(["ss", "-tlnp"], capture_output=True, text=True)
    nginx_ports = [line for line in result.stdout.split('\n') if 'nginx' in line.lower()]
    if nginx_ports:
        print("\nNginx 监听端口:")
        for line in nginx_ports:
            print(f"  {line}")


def main():
    if len(sys.argv) > 1 and sys.argv[1] == "status":
        show_status()
        return
    
    print("Olares Nginx 配置生成器")
    print("="*60)
    
    # 获取已部署的应用
    print("\n1. 扫描已部署的应用...")
    apps = get_deployed_apps()
    
    if not apps:
        print("  未找到已部署的应用")
        return
    
    print(f"  找到 {len(apps)} 个应用:")
    for app in apps:
        print(f"    - {app['name']} (端口 {app['port']})")
    
    # 生成配置
    print("\n2. 生成 Nginx 配置...")
    write_nginx_configs(apps)
    
    # 重载 Nginx
    print("\n3. 应用配置...")
    if reload_nginx():
        show_status()
        print("\n✅ 配置完成！")
    else:
        print("\n❌ 配置失败")
        sys.exit(1)


if __name__ == "__main__":
    main()
